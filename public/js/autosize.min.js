const map='function'==typeof Map?new Map:function(){const a=[],b=[];return{has(c){return-1<a.indexOf(c)},get(c){return b[a.indexOf(c)]},set(c,d){-1===a.indexOf(c)&&(a.push(c),b.push(d))},delete(c){const d=a.indexOf(c);-1<d&&(a.splice(d,1),b.splice(d,1))}}}();let createEvent=a=>new Event(a,{bubbles:!0});try{new Event('test')}catch(a){createEvent=b=>{const c=document.createEvent('Event');return c.initEvent(b,!0,!1),c}}function assign(a){function b(){const m=window.getComputedStyle(a,null);'vertical'===m.resize?a.style.resize='none':'both'===m.resize&&(a.style.resize='horizontal'),h='content-box'===m.boxSizing?-(parseFloat(m.paddingTop)+parseFloat(m.paddingBottom)+30):parseFloat(m.borderTopWidth)+parseFloat(m.borderBottomWidth)+30,isNaN(h)&&(h=0),g()}function c(m){{const n=a.style.width;a.style.width='0px',a.offsetWidth,a.style.width=n}a.style.overflowY=m}function d(m){const n=[];for(;m&&m.parentNode&&m.parentNode instanceof Element;)m.parentNode.scrollTop&&n.push({node:m.parentNode,scrollTop:m.parentNode.scrollTop}),m=m.parentNode;return n}function f(){if(0!==a.scrollHeight){const m=d(a),n=document.documentElement&&document.documentElement.scrollTop;a.style.height='',a.style.height=a.scrollHeight+h+40+'px',i=a.clientWidth,m.forEach(o=>{o.node.scrollTop=o.scrollTop}),n&&(document.documentElement.scrollTop=n)}}function g(){f();const m=Math.round(parseFloat(a.style.height)),n=window.getComputedStyle(a,null);var o='content-box'===n.boxSizing?Math.round(parseFloat(n.height)):a.offsetHeight;if(o<m?'hidden'===n.overflowY&&(c('scroll'),f(),o='content-box'===n.boxSizing?Math.round(parseFloat(window.getComputedStyle(a,null).height)):a.offsetHeight):'hidden'!==n.overflowY&&(c('hidden'),f(),o='content-box'===n.boxSizing?Math.round(parseFloat(window.getComputedStyle(a,null).height)):a.offsetHeight),j!==o){j=o;const p=createEvent('autosize:resized');try{a.dispatchEvent(p)}catch(q){}}}if(a&&a.nodeName&&'TEXTAREA'===a.nodeName&&!map.has(a)){const k=()=>{a.clientWidth!==null&&g()},l=(m=>{window.removeEventListener('resize',k,!1),a.removeEventListener('input',g,!1),a.removeEventListener('keyup',g,!1),a.removeEventListener('focus',g,!1),a.removeEventListener('autosize:destroy',l,!1),a.removeEventListener('autosize:update',g,!1),Object.keys(m).forEach(n=>{a.style[n]=m[n]}),map.delete(a)}).bind(a,{height:a.style.height,resize:a.style.resize,overflowY:a.style.overflowY,overflowX:a.style.overflowX,wordWrap:a.style.wordWrap});a.addEventListener('autosize:destroy',l,!1),'onpropertychange'in a&&'oninput'in a&&(a.addEventListener('keyup',g,!1),a.addEventListener('focus',g,!1)),window.addEventListener('resize',k,!1),a.addEventListener('input',g,!1),a.addEventListener('focus',g,!1),a.addEventListener('autosize:update',g,!1),a.style.overflowX='hidden',a.style.wordWrap='break-word',map.set(a,{destroy:l,update:g}),b()}}function destroy(a){const b=map.get(a);b&&b.destroy()}function update(a){const b=map.get(a);b&&b.update()}let autosize=null;'undefined'==typeof window||'function'!=typeof window.getComputedStyle?(autosize=a=>a,autosize.destroy=a=>a,autosize.update=a=>a):(autosize=(a,b)=>{return a&&Array.prototype.forEach.call(a.length?a:[a],c=>assign(c,b)),a},autosize.destroy=a=>{return a&&Array.prototype.forEach.call(a.length?a:[a],destroy),a},autosize.update=a=>{return a&&Array.prototype.forEach.call(a.length?a:[a],update),a});